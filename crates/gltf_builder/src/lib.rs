pub mod trait_components;
use trait_components::MinMaxComponents;
pub mod trait_le_bytes;
use trait_le_bytes::WriteLEBytes;
pub mod types;
pub use types::{Result, Vector2, Vector3, Vector4};

use base64::Engine;
use eyre::eyre;
use gltf_json::{
    accessor::{ComponentType, GenericComponentType, Type},
    buffer,
    image::MimeType,
    material::{
        AlphaCutoff, AlphaMode, EmissiveFactor, NormalTexture, OcclusionTexture,
        PbrMetallicRoughness,
    },
    mesh::{Mode, Primitive, Semantic},
    texture::Info,
    validation::{Checked, Validate},
    Accessor, Buffer, Image, Index, Material, Mesh, Node, Root, Scene, Skin, Texture, Value,
};
use serde_json::json;
use std::{collections::HashMap, mem::size_of};

use crate::types::Matrix4;

/// 10 MB
const ARBITRARY_BUFFER_LENGTH_LIMIT: u32 = 2u32.pow(10 * 2);

/// This trait is used to add something to a list and returns the index it was put at.
trait PushReturnIndex {
    type Input;
    /// This adds something to a list and returns the index it was put at.
    fn push_indexed(&mut self, data: Self::Input) -> usize;
}

impl<T> PushReturnIndex for Vec<T> {
    type Input = T;

    fn push_indexed(&mut self, data: Self::Input) -> usize {
        self.push(data);
        self.len() - 1
    }
}

#[derive(Debug, Default)]
#[allow(non_camel_case_types)]
pub struct glTFBuilder {
    root: Root,
    unencoded_buffers: HashMap<Index<Buffer>, Vec<u8>>,
    autogenerated_index: usize,
}

/// Internal functions.
impl glTFBuilder {
    /// This will throw an [`Result::Err`] if the internal [`gltf_json`] validation of our [`Root`] fails.
    /// Used to ensure the state is always valid after every public function call.
    ///
    /// During the process of the call and during internal calls, the state is allowed to be invalid, as we hold a &mut self.
    /// This is unfortunately necessary because some operations require insertions into two different parts of the struct,
    /// which cannot be done in parallel.
    fn check_validity(&self) -> crate::Result<()> {
        let mut errors = Vec::new();
        self.root
            .validate(&self.root, gltf_json::Path::new, &mut |path, error| {
                errors.push((path(), error))
            });

        // Make sure our mesh is valid!
        if !errors.is_empty() {
            return Err(eyre!("{:#?}", errors));
        }

        Ok(())
    }

    /// This helper returns an immutable reference to
    /// both the real unencoded data from [`glTFBuilder::unencoded_buffers`]
    /// as well as the [`Buffer`] entry, so that internal functions can view the
    /// data as if it were combined.
    #[allow(dead_code)]
    fn get_buffer(&self, buffer: Index<Buffer>) -> (&Vec<u8>, &Buffer) {
        (
            self.unencoded_buffers.get(&buffer).unwrap(),
            self.root.buffers.get(buffer.value()).unwrap(),
        )
    }

    /// This helper returns a mutable reference to
    /// both the real unencoded data from [`glTFBuilder::unencoded_buffers`]
    /// as well as the [`Buffer`] entry, so that internal functions can mutate the
    /// data as if it were combined.
    fn get_buffer_mut(&mut self, buffer: Index<Buffer>) -> (&mut Vec<u8>, &mut Buffer) {
        (
            self.unencoded_buffers.get_mut(&buffer).unwrap(),
            self.root.buffers.get_mut(buffer.value()).unwrap(),
        )
    }

    /// This creates a new [`Buffer`] backed by a [`Vec<u8>`]
    /// in [`glTFBuilder::unencoded_buffers`].
    fn create_buffer(&mut self, name: Option<&str>) -> Index<Buffer> {
        let buffer_type = Buffer {
            byte_length: 0,
            name: name.map(|x| x.to_owned()),
            uri: None,
            extensions: None,
            extras: Default::default(),
        };

        let index = Index::new(self.root.buffers.push_indexed(buffer_type) as u32);

        self.unencoded_buffers.insert(index, Vec::new());

        index
    }

    /// This inserts additional data into an existing [`Buffer`] and
    /// creates a new [`buffer::View`] to that data, then returns
    /// an index to the newly created [`buffer::View`].
    ///
    /// This exists for skipping the overhead and... shakiness of [`WriteGltf`].
    fn insert_raw_data(
        &mut self,
        name: Option<&str>,
        buffer: Index<Buffer>,
        data: &[u8],
    ) -> Index<buffer::View> {
        let (real_buffer, buffer_type) = self.get_buffer_mut(buffer);

        // The index offset of the buffer view into this buffer will be whatever our current
        // length is. However, the glTF spec asks that we simply don't encode the offset if
        // it is 0, so we have to account for that.
        let potential_offset = real_buffer.len() as u32;
        let byte_offset = if potential_offset != 0 {
            Some(potential_offset)
        } else {
            None
        };

        // Write the data to the end of the real unencoded vec.
        real_buffer.extend(data);

        // Always synchronize the buffer_type length.
        buffer_type.byte_length = real_buffer.len() as u32;

        let buffer_view = buffer::View {
            buffer,
            byte_length: data.len() as u32,
            byte_offset,
            byte_stride: None,
            name: name.map(|x| x.to_owned()),
            target: None,
            extensions: None,
            extras: Default::default(),
        };

        Index::new(self.root.buffer_views.push_indexed(buffer_view) as u32)
    }

    /// This inserts additional data into an existing [`Buffer`] and
    /// creates a new [`buffer::View`] to that data, then returns
    /// an index to the newly created [`buffer::View`].
    fn insert_write_gltf<T: WriteLEBytes>(
        &mut self,
        name: Option<&str>,
        buffer: Index<Buffer>,
        data: T,
    ) -> Index<buffer::View> {
        let (real_buffer, buffer_type) = self.get_buffer_mut(buffer);

        // The index offset of the buffer view into this buffer will be whatever our current
        // length is. However, the glTF spec asks that we simply don't encode the offset if
        // it is 0, so we have to account for that.
        let potential_offset = real_buffer.len() as u32;
        let byte_offset = if potential_offset != 0 {
            Some(potential_offset)
        } else {
            None
        };

        data.write_gltf(real_buffer);

        let byte_length = real_buffer.len() as u32 - potential_offset;

        // Always synchronize the buffer_type length.
        buffer_type.byte_length = real_buffer.len() as u32;

        let buffer_view = buffer::View {
            buffer,
            byte_length,
            byte_offset,
            byte_stride: None,
            name: name.map(|x| x.to_owned()),
            target: None,
            extensions: None,
            extras: Default::default(),
        };

        Index::new(self.root.buffer_views.push_indexed(buffer_view) as u32)
    }

    /// Most accessor data types must be aligned. This has to be accounted for
    /// by adding padding to our [`Buffer`]s. This will automatically pad if needed.
    ///
    /// This won't cause any issues, as [`Buffer`]s are always accessed through
    /// [`BufferView`]s which we ensure are valid when they are created,
    /// and this function will never modify any data already referenced.
    ///
    /// Example: an f32 accessor will ask:
    /// ```no_compile
    /// self.pad_to_alignment(index, std::mem::size_of::<f32>());
    /// ```
    fn pad_to_alignment(&mut self, buffer: Index<Buffer>, alignment: usize) {
        let (real_buffer, buffer_type) = self.get_buffer_mut(buffer);

        // This may do nothing if it is already padded, that's okay.
        while real_buffer.len() % alignment != 0 {
            // Zero-pad.
            real_buffer.push(0);
        }

        // Update the byte length.
        buffer_type.byte_length = real_buffer.len() as u32;
    }

    /// This will automatically select or create a buffer based on the following rules:
    /// 1. If there are no buffers, create a new one.
    /// 2. If there is a buffer, keep appending to it up to [`ARBITRARY_BUFFER_LENGTH_LIMIT`].
    fn auto_buffer(&mut self, data_size: usize) -> Index<Buffer> {
        if let Some(last) = self.root.buffers.last() {
            if last.byte_length + data_size as u32 > ARBITRARY_BUFFER_LENGTH_LIMIT {
                let buf = self.create_buffer(Some(&format!(
                    "Autogenerated buffer {}",
                    self.autogenerated_index
                )));
                self.autogenerated_index += 1;
                buf
            } else {
                Index::new(self.root.buffers.len() as u32 - 1)
            }
        } else {
            let buf = self.create_buffer(Some(&format!(
                "Autogenerated buffer {}",
                self.autogenerated_index
            )));
            self.autogenerated_index += 1;
            buf
        }
    }

    /// Creates a new [`Accessor`] and immediately checks it's validity, otherwise fails.
    ///
    /// It is up to the caller to ensure the buffer_view is aligned correctly.
    #[allow(clippy::too_many_arguments)]
    fn create_accessor(
        &mut self,
        name: Option<&str>,
        buffer_view: Index<buffer::View>,
        byte_offset: u32,
        count: u32,
        component_type: Checked<GenericComponentType>,
        outer_type: Checked<Type>,
        min: Option<Value>,
        max: Option<Value>,
        normalized: bool,
    ) -> Result<Index<Accessor>> {
        let index = self.root.accessors.push_indexed(Accessor {
            buffer_view: Some(buffer_view),
            byte_offset,
            count,
            component_type,
            extensions: None,
            extras: Default::default(),
            type_: outer_type,
            min,
            max,
            name: name.map(|s| s.to_owned()),
            normalized,
            sparse: None,
        });

        Ok(Index::new(index as u32))
    }

    /// This is a shortcut to create an [`Accessor`] with [`ComponentType::U16`] and [`Type::Vec4`]
    ///
    /// As with [`create_accessor`], it's up to the caller to pad the buffer to the right alignment
    /// before calling this function.
    #[allow(dead_code)]
    fn create_accessor_vec4_u16(
        &mut self,
        name: Option<&str>,
        buffer_view: Index<buffer::View>,
        data: &[[u16; 4]],
    ) -> Result<Index<Accessor>> {
        self.create_accessor(
            name,
            buffer_view,
            0,
            data.len() as u32,
            Checked::Valid(GenericComponentType(ComponentType::U16)),
            Checked::Valid(Type::Vec4),
            data.min_components().map(|f| json!(f)),
            data.max_components().map(|f| json!(f)),
            false,
        )
    }

    /// This is a shortcut to create an [`Accessor`] with [`ComponentType::U32`] and [`Type::Vec4`]
    ///
    /// As with [`create_accessor`], it's up to the caller to pad the buffer to the right alignment
    /// before calling this function.
    #[allow(dead_code)]
    fn create_accessor_vec4_u32(
        &mut self,
        name: Option<&str>,
        buffer_view: Index<buffer::View>,
        data: &[[u32; 4]],
    ) -> Result<Index<Accessor>> {
        self.create_accessor(
            name,
            buffer_view,
            0,
            data.len() as u32,
            Checked::Valid(GenericComponentType(ComponentType::U32)),
            Checked::Valid(Type::Vec4),
            data.min_components().map(|f| json!(f)),
            data.max_components().map(|f| json!(f)),
            false,
        )
    }

    /// This is a shortcut to create an [`Accessor`] with [`ComponentType::F32`] and [`Type::Vec4`]
    ///
    /// As with [`create_accessor`], it's up to the caller to pad the buffer to the right alignment
    /// before calling this function.
    #[allow(dead_code)]
    fn create_accessor_vec4(
        &mut self,
        name: Option<&str>,
        buffer_view: Index<buffer::View>,
        data: &[Vector4],
    ) -> Result<Index<Accessor>> {
        self.create_accessor(
            name,
            buffer_view,
            0,
            data.len() as u32,
            Checked::Valid(GenericComponentType(ComponentType::F32)),
            Checked::Valid(Type::Vec4),
            data.min_components().map(|f| json!(f)),
            data.max_components().map(|f| json!(f)),
            false,
        )
    }

    /// This is a shortcut to create an [`Accessor`] with [`ComponentType::F32`] and [`Type::Vec4`]
    ///
    /// As with [`create_accessor`], it's up to the caller to pad the buffer to the right alignment
    /// before calling this function.
    #[allow(dead_code)]
    fn create_accessor_mat4(
        &mut self,
        name: Option<&str>,
        buffer_view: Index<buffer::View>,
        data: &[Matrix4],
    ) -> Result<Index<Accessor>> {
        self.create_accessor(
            name,
            buffer_view,
            0,
            data.len() as u32,
            Checked::Valid(GenericComponentType(ComponentType::F32)),
            Checked::Valid(Type::Mat4),
            data.min_components().map(|f| json!(f)),
            data.max_components().map(|f| json!(f)),
            false,
        )
    }

    /// This is a shortcut to create an [`Accessor`] with [`ComponentType::F32`] and [`Type::Vec3`]
    ///
    /// As with [`create_accessor`], it's up to the caller to pad the buffer to the right alignment
    /// before calling this function.
    fn create_accessor_vec3(
        &mut self,
        name: Option<&str>,
        buffer_view: Index<buffer::View>,
        data: &[Vector3],
    ) -> Result<Index<Accessor>> {
        self.create_accessor(
            name,
            buffer_view,
            0,
            data.len() as u32,
            Checked::Valid(GenericComponentType(ComponentType::F32)),
            Checked::Valid(Type::Vec3),
            data.min_components().map(|f| json!(f)),
            data.max_components().map(|f| json!(f)),
            false,
        )
    }

    /// This is a shortcut to create an [`Accessor`] with [`ComponentType::F32`] and [`Type::Vec2`]
    ///
    /// As with [`create_accessor`], it's up to the caller to pad the buffer to the right alignment
    /// before calling this function.
    fn create_accessor_vec2(
        &mut self,
        name: Option<&str>,
        buffer_view: Index<buffer::View>,
        data: &[Vector2],
    ) -> Result<Index<Accessor>> {
        self.create_accessor(
            name,
            buffer_view,
            0,
            data.len() as u32,
            Checked::Valid(GenericComponentType(ComponentType::F32)),
            Checked::Valid(Type::Vec2),
            data.min_components().map(|f| json!(f)),
            data.max_components().map(|f| json!(f)),
            false,
        )
    }

    /// This is a shortcut to create an [`Accessor`] with [`ComponentType::F32`] and [`Type::Vec2`]
    ///
    /// As with [`create_accessor`], it's up to the caller to pad the buffer to the right alignment
    /// before calling this function.
    fn create_accessor_vec_u32(
        &mut self,
        name: Option<&str>,
        buffer_view: Index<buffer::View>,
        data: &[u32],
    ) -> Result<Index<Accessor>> {
        self.create_accessor(
            name,
            buffer_view,
            0,
            data.len() as u32,
            Checked::Valid(GenericComponentType(ComponentType::U32)),
            Checked::Valid(Type::Scalar),
            // Trivial to determine but it doesn't like us providing
            None,
            None,
            false,
        )
    }

    /// Inserts [`Vec<[u16; 4]>`] data, like bones.
    fn insert_vec4_u16(&mut self, name: &str, data: &[[u16; 4]]) -> Result<Index<Accessor>> {
        let buffer = self.auto_buffer(data.len() * size_of::<u16>() * 4);
        self.pad_to_alignment(buffer, size_of::<u16>());
        let buffer_view = self.insert_write_gltf(Some(name), buffer, data);
        self.create_accessor_vec4_u16(Some(name), buffer_view, data)
    }

    /// Inserts [`Vec<[u32; 4]>`] data, like bones.
    #[allow(dead_code)]
    fn insert_vec4_u32(&mut self, name: &str, data: &[[u32; 4]]) -> Result<Index<Accessor>> {
        let buffer = self.auto_buffer(data.len() * size_of::<u32>() * 4);
        self.pad_to_alignment(buffer, size_of::<u32>());
        let buffer_view = self.insert_write_gltf(Some(name), buffer, data);
        self.create_accessor_vec4_u32(Some(name), buffer_view, data)
    }

    /// Inserts [`Vec<Matrix4>`] data, like weights.
    fn insert_mat4(&mut self, name: &str, data: &[Matrix4]) -> Result<Index<Accessor>> {
        let buffer = self.auto_buffer(data.len() * size_of::<f32>() * 4 * 4);
        self.pad_to_alignment(buffer, size_of::<f32>());
        let buffer_view = self.insert_write_gltf(Some(name), buffer, data);
        self.create_accessor_mat4(Some(name), buffer_view, data)
    }

    /// Inserts [`Vec<Vector4>`] data, like weights.
    fn insert_vec4(&mut self, name: &str, data: &[Vector4]) -> Result<Index<Accessor>> {
        let buffer = self.auto_buffer(data.len() * size_of::<f32>() * 4);
        self.pad_to_alignment(buffer, size_of::<f32>());
        let buffer_view = self.insert_write_gltf(Some(name), buffer, data);
        self.create_accessor_vec4(Some(name), buffer_view, data)
    }

    /// Inserts [`Vec<Vector3>`] data, like positions.
    fn insert_vec3(&mut self, name: &str, data: &[Vector3]) -> Result<Index<Accessor>> {
        let buffer = self.auto_buffer(data.len() * size_of::<f32>() * 3);
        self.pad_to_alignment(buffer, size_of::<f32>());
        let buffer_view = self.insert_write_gltf(Some(name), buffer, data);
        self.create_accessor_vec3(Some(name), buffer_view, data)
    }

    /// Inserts [`Vec<Vector2>`] data, like UVs.
    fn insert_vec2(&mut self, name: &str, data: &[Vector2]) -> Result<Index<Accessor>> {
        let buffer = self.auto_buffer(data.len() * size_of::<f32>() * 2);
        self.pad_to_alignment(buffer, size_of::<f32>());
        let buffer_view = self.insert_write_gltf(Some(name), buffer, data);
        self.create_accessor_vec2(Some(name), buffer_view, data)
    }

    /// Inserts [`Vec<u32>`] data, like Indices.
    fn insert_vec_u32(&mut self, name: &str, data: &[u32]) -> Result<Index<Accessor>> {
        let buffer = self.auto_buffer(data.len() * size_of::<u32>());
        self.pad_to_alignment(buffer, size_of::<u32>());
        let buffer_view = self.insert_write_gltf(Some(name), buffer, data);
        self.create_accessor_vec_u32(Some(name), buffer_view, data)
    }

    /// Steps to build:
    /// - Base64 encode [`glTFBuilder::unencoded_buffers`] and place them in their respective [`Buffer::uri`] fields.
    ///   - TODO: Eventually this should support the other two methods of storing buffers, glb and .bin files; do this here.
    /// - Return [`serde_json::to_string(root)`].
    fn build_internal(mut self) -> Result<String> {
        self.unencoded_buffers.iter().for_each(|(idx, buf)| {
            let mut encoded = "data:application/octet-stream;base64,".to_owned();
            base64::engine::general_purpose::STANDARD.encode_string(buf, &mut encoded);
            self.root.buffers.get_mut(idx.value()).unwrap().uri = Some(encoded);
        });

        Ok(serde_json::to_string_pretty(&self.root)?)
    }
}

/// Public functions.
impl glTFBuilder {
    /// Constructs a new gltfBuilder with a valid, default internal representation.
    pub fn new() -> Self {
        Self::default()
    }

    /// Finalize the [`glTFBuilder`] and return the json encoded [`Root`].
    pub fn build(self) -> Result<String> {
        // Always check validity before returning our built gltf.
        self.check_validity()?;
        self.build_internal()
    }

    /// Inserts an image.
    pub fn insert_image(
        &mut self,
        name: &str,
        mime_type: Option<MimeType>,
        data: &[u8],
    ) -> Result<Index<Image>> {
        let buffer = self.auto_buffer(data.len());
        let buffer_view = self.insert_raw_data(Some(name), buffer, data);

        let idx = self.root.images.push_indexed(Image {
            buffer_view: Some(buffer_view),
            mime_type,
            name: Some(name.into()),
            uri: None,
            extensions: None,
            extras: Default::default(),
        });

        // Skip validation in release mode.
        #[cfg(not(debug_assertions))]
        self.check_validity()?;

        Ok(Index::new(idx as u32))
    }

    /// Inserts an image using a URI instead of a buffer.
    pub fn insert_image_uri(
        &mut self,
        name: &str,
        mime_type: Option<MimeType>,
        uri: &str,
    ) -> Result<Index<Image>> {
        let idx = self.root.images.push_indexed(Image {
            buffer_view: None,
            mime_type,
            name: Some(name.into()),
            uri: Some(uri.into()),
            extensions: None,
            extras: Default::default(),
        });

        // Skip validation in release mode.
        #[cfg(not(debug_assertions))]
        self.check_validity()?;

        Ok(Index::new(idx as u32))
    }

    /// Inserts a texture given a name and image.
    pub fn insert_texture(&mut self, name: &str, image: Index<Image>) -> Result<Index<Texture>> {
        let idx = self.root.textures.push_indexed(Texture {
            name: Some(name.to_owned()),
            // TODO: Change this if textures turn out badly
            sampler: None,
            source: image,
            extensions: None,
            extras: Default::default(),
        });

        // Skip validation in release mode.
        #[cfg(not(debug_assertions))]
        self.check_validity()?;

        Ok(Index::new(idx as u32))
    }

    /// Inserts a new mesh.
    pub fn insert_mesh(&mut self, name: &str) -> Index<Mesh> {
        Index::new(self.root.meshes.push_indexed(Mesh {
            extensions: Default::default(),
            extras: Default::default(),
            name: Some(name.into()),
            primitives: Default::default(),
            weights: Default::default(),
        }) as u32)
    }

    pub fn insert_primitive(&mut self, mesh: Index<Mesh>, mode: Mode) -> Index<Primitive> {
        let mesh = self.root.meshes.get_mut(mesh.value()).unwrap();

        Index::new(mesh.primitives.push_indexed(Primitive {
            attributes: Default::default(),
            extensions: Default::default(),
            extras: Default::default(),
            indices: Default::default(),
            material: Default::default(),
            mode: Checked::Valid(mode),
            targets: Default::default(),
        }) as u32)
    }

    pub fn insert_positions(
        &mut self,
        mesh: Index<Mesh>,
        primitive: Index<Primitive>,
        data: &[Vector3],
    ) -> Result<()> {
        let accessor = self.insert_vec3(
            &format!(
                "{} vertex positions",
                self.root
                    .meshes
                    .get(mesh.value())
                    .unwrap()
                    .name
                    .as_ref()
                    .unwrap()
            ),
            data,
        )?;

        let mesh = self.root.meshes.get_mut(mesh.value()).unwrap();
        let primitive = mesh.primitives.get_mut(primitive.value()).unwrap();

        primitive
            .attributes
            .insert(Checked::Valid(Semantic::Positions), accessor);

        Ok(())
    }

    pub fn insert_normals(
        &mut self,
        mesh: Index<Mesh>,
        primitive: Index<Primitive>,
        data: &[Vector3],
    ) -> Result<()> {
        let accessor = self.insert_vec3(
            &format!(
                "{} normals",
                self.root
                    .meshes
                    .get(mesh.value())
                    .unwrap()
                    .name
                    .as_ref()
                    .unwrap()
            ),
            data,
        )?;

        let mesh = self.root.meshes.get_mut(mesh.value()).unwrap();
        let primitive = mesh.primitives.get_mut(primitive.value()).unwrap();

        primitive
            .attributes
            .insert(Checked::Valid(Semantic::Normals), accessor);

        Ok(())
    }

    pub fn insert_inverse_bind_matrices(
        &mut self,
        skin: Index<Skin>,
        data: &[Matrix4],
    ) -> Result<()> {
        let accessor = self.insert_mat4(
            &format!(
                "{} weights",
                self.root
                    .skins
                    .get(skin.value())
                    .unwrap()
                    .name
                    .as_ref()
                    .unwrap()
            ),
            data,
        )?;

        let skin = self.root.skins.get_mut(skin.value()).unwrap();

        skin.inverse_bind_matrices = Some(accessor);

        Ok(())
    }

    pub fn insert_weights(
        &mut self,
        mesh: Index<Mesh>,
        primitive: Index<Primitive>,
        data: &[Vector4],
    ) -> Result<()> {
        let accessor = self.insert_vec4(
            &format!(
                "{} weights",
                self.root
                    .meshes
                    .get(mesh.value())
                    .unwrap()
                    .name
                    .as_ref()
                    .unwrap()
            ),
            data,
        )?;

        let mesh = self.root.meshes.get_mut(mesh.value()).unwrap();
        let primitive = mesh.primitives.get_mut(primitive.value()).unwrap();

        primitive
            .attributes
            .insert(Checked::Valid(Semantic::Weights(0)), accessor);

        Ok(())
    }

    pub fn insert_joints(
        &mut self,
        mesh: Index<Mesh>,
        primitive: Index<Primitive>,
        data: &[[u16; 4]],
    ) -> Result<()> {
        let accessor = self.insert_vec4_u16(
            &format!(
                "{} joints",
                self.root
                    .meshes
                    .get(mesh.value())
                    .unwrap()
                    .name
                    .as_ref()
                    .unwrap()
            ),
            data,
        )?;

        let mesh = self.root.meshes.get_mut(mesh.value()).unwrap();
        let primitive = mesh.primitives.get_mut(primitive.value()).unwrap();

        primitive
            .attributes
            .insert(Checked::Valid(Semantic::Joints(0)), accessor);

        Ok(())
    }

    pub fn insert_uv_map(
        &mut self,
        mesh: Index<Mesh>,
        primitive: Index<Primitive>,
        data: &[Vector2],
    ) -> Result<()> {
        let accessor = self.insert_vec2(
            &format!(
                "{} uv map",
                self.root
                    .meshes
                    .get(mesh.value())
                    .unwrap()
                    .name
                    .as_ref()
                    .unwrap()
            ),
            data,
        )?;

        let mesh = self.root.meshes.get_mut(mesh.value()).unwrap();
        let primitive = mesh.primitives.get_mut(primitive.value()).unwrap();

        primitive
            .attributes
            .insert(Checked::Valid(Semantic::TexCoords(0)), accessor);

        Ok(())
    }

    pub fn insert_indices(
        &mut self,
        mesh: Index<Mesh>,
        primitive: Index<Primitive>,
        data: &[u32],
    ) -> Result<()> {
        let accessor = self.insert_vec_u32(
            &format!(
                "{} indices",
                self.root
                    .meshes
                    .get(mesh.value())
                    .unwrap()
                    .name
                    .as_ref()
                    .unwrap()
            ),
            data,
        )?;

        let mesh = self.root.meshes.get_mut(mesh.value()).unwrap();
        let primitive = mesh.primitives.get_mut(primitive.value()).unwrap();

        primitive.indices = Some(accessor);

        Ok(())
    }

    #[allow(clippy::too_many_arguments)]
    pub fn insert_material(
        &mut self,
        name: &str,
        alpha_cutoff: Option<AlphaCutoff>,
        alpha_mode: AlphaMode,
        double_sided: bool,
        pbr_metallic_roughness: PbrMetallicRoughness,
        normal_texture: Option<NormalTexture>,
        occlusion_texture: Option<OcclusionTexture>,
        emissive_texture: Option<Info>,
        emissive_factor: EmissiveFactor,
    ) -> Index<Material> {
        Index::new(self.root.materials.push_indexed(Material {
            alpha_cutoff,
            alpha_mode: Checked::Valid(alpha_mode),
            double_sided,
            name: Some(name.into()),
            pbr_metallic_roughness,
            normal_texture,
            occlusion_texture,
            emissive_texture,
            emissive_factor,
            extensions: Default::default(),
            extras: Default::default(),
        }) as u32)
    }

    pub fn set_primitive_material(
        &mut self,
        mesh: Index<Mesh>,
        primitive: Index<Primitive>,
        material: Index<Material>,
    ) {
        let mesh = self.root.meshes.get_mut(mesh.value()).unwrap();
        let primitive = mesh.primitives.get_mut(primitive.value()).unwrap();
        primitive.material = Some(material);
    }

    pub fn insert_node(&mut self, node: Node) -> Index<Node> {
        Index::new(self.root.nodes.push_indexed(node) as u32)
    }

    pub fn insert_mesh_skin_node(
        &mut self,
        name: &str,
        mesh: Index<Mesh>,
        skin: Index<Skin>,
    ) -> Index<Node> {
        self.insert_node(Node {
            camera: None,
            children: None,
            extensions: Default::default(),
            extras: Default::default(),
            matrix: None,
            mesh: Some(mesh),
            name: Some(name.into()),
            rotation: None,
            scale: None,
            translation: None,
            skin: Some(skin),
            weights: None,
        })
    }

    pub fn insert_mesh_node(&mut self, name: &str, mesh: Index<Mesh>) -> Index<Node> {
        self.insert_node(Node {
            camera: None,
            children: None,
            extensions: Default::default(),
            extras: Default::default(),
            matrix: None,
            mesh: Some(mesh),
            name: Some(name.into()),
            rotation: None,
            scale: None,
            translation: None,
            skin: None,
            weights: None,
        })
    }

    pub fn insert_skin(&mut self, skin: Skin) -> Index<Skin> {
        Index::new(self.root.skins.push_indexed(skin) as u32)
    }

    pub fn insert_node_child(&mut self, parent_idx: Index<Node>, child: Index<Node>) {
        let parent = self.root.nodes.get_mut(parent_idx.value()).unwrap();

        if let Some(child_list) = &mut parent.children {
            child_list.push(child);
        } else {
            parent.children = Some(vec![child]);
        }
    }

    pub fn insert_scene(
        &mut self,
        name: &str,
        default: bool,
        nodes: &[Index<Node>],
    ) -> Index<Scene> {
        let idx = Index::new(self.root.scenes.push_indexed(Scene {
            extensions: Default::default(),
            extras: Default::default(),
            name: Some(name.into()),
            nodes: nodes.to_vec(),
        }) as u32);
        if default {
            self.root.scene = Some(idx);
        }
        idx
    }

    pub fn set_generator(&mut self, generator: &str) {
        self.root.asset.generator = Some(generator.into())
    }
}

#[cfg(test)]
mod tests {
    use crate::glTFBuilder;
    use gltf_json::{accessor::Type, image::MimeType, Buffer, Index};
    use std::mem::size_of;

    fn helper_setup_buffer(builder: &mut glTFBuilder) -> Index<Buffer> {
        let idx = builder.create_buffer(Some("Test Buffer"));
        assert_eq!(idx.value(), 0);
        idx
    }

    #[test]
    fn test_default_is_valid() {
        glTFBuilder::new().check_validity().unwrap()
    }

    #[test]
    fn test_buffer_is_created() {
        let mut builder = glTFBuilder::new();
        let index = helper_setup_buffer(&mut builder);

        assert_eq!(builder.root.buffers.len(), 1);

        let (_, new_buffer) = &builder.get_buffer(index);

        assert_eq!(new_buffer.byte_length, 0);
        assert_eq!(new_buffer.name, Some("Test Buffer".into()));
        assert_eq!(new_buffer.uri, None);

        builder.check_validity().unwrap()
    }

    #[test]
    fn test_buffer_view_is_created() {
        let mut builder = glTFBuilder::new();
        let buffer_idx = helper_setup_buffer(&mut builder);

        let buffer_view_idx = builder.insert_raw_data(Some("Test Data"), buffer_idx, &[1, 2, 3]);

        assert_eq!(buffer_view_idx.value(), 0);
        assert_eq!(builder.root.buffer_views.len(), 1);

        let new_buffer_view = &builder.root.buffer_views[0];

        assert_eq!(new_buffer_view.buffer.value(), 0);
        assert_eq!(new_buffer_view.byte_length, 3);
        assert_eq!(new_buffer_view.byte_offset, None);
        assert_eq!(new_buffer_view.name, Some("Test Data".into()));

        let existing_buffer = &builder.root.buffers[0];
        assert_eq!(existing_buffer.byte_length, 3);

        builder.check_validity().unwrap()
    }

    #[test]
    fn test_multiple_views() {
        let mut builder = glTFBuilder::new();
        let buffer_idx = helper_setup_buffer(&mut builder);
        let buffer_view_idx_1 = builder.insert_raw_data(Some("Test Data"), buffer_idx, &[1, 2, 3]);
        assert_eq!(buffer_view_idx_1.value(), 0);
        let buffer_view_idx_2 =
            builder.insert_raw_data(Some("Test Data 2"), buffer_idx, &[4, 5, 6]);
        assert_eq!(buffer_view_idx_2.value(), 1);

        let buffer_views = &builder.root.buffer_views;
        assert_eq!(buffer_views.len(), 2);
        assert_eq!(buffer_views[0].byte_length, 3);
        assert_eq!(buffer_views[1].byte_length, 3);
        assert_eq!(buffer_views[1].byte_offset, Some(3));

        assert_eq!(builder.root.buffers.len(), 1);
        let (real_buffer, buffer) = builder.get_buffer(buffer_idx);

        assert_eq!(buffer.byte_length, 6);
        assert_eq!(buffer.uri, None);
        assert_eq!(real_buffer.len() as u32, buffer.byte_length);
        assert_eq!(real_buffer.first(), Some(&1));
        assert_eq!(real_buffer.last(), Some(&6));

        builder.check_validity().unwrap()
    }

    #[test]
    fn test_padding() {
        let mut builder = glTFBuilder::new();
        let buffer_idx = helper_setup_buffer(&mut builder);
        let buffer_view = builder.insert_raw_data(None, buffer_idx, &[1, 2]);

        let (real_buffer, _) = builder.get_buffer(buffer_idx);
        assert_eq!(real_buffer.len(), 2);

        builder.pad_to_alignment(buffer_idx, std::mem::size_of::<f32>());

        let (real_buffer, _) = builder.get_buffer(buffer_idx);
        assert_eq!(real_buffer.len(), 4);

        assert_eq!(
            builder
                .root
                .buffer_views
                .get(buffer_view.value())
                .unwrap()
                .byte_length,
            2
        );

        // Should still be valid at this point.
        builder.check_validity().unwrap();

        let new_buffer_view = builder.insert_raw_data(None, buffer_idx, &[3, 4]);
        let (real_buffer, _) = builder.get_buffer(buffer_idx);
        assert_eq!(real_buffer.len(), 6);

        assert_eq!(
            builder
                .root
                .buffer_views
                .get(new_buffer_view.value())
                .unwrap()
                .byte_offset,
            Some(4)
        );

        // Should still be valid at this point.
        builder.check_validity().unwrap();
    }

    #[test]
    fn test_image() {
        let data = include_bytes!("test_files/basn0g01.png");

        let mut builder = glTFBuilder::new();
        let image = builder
            .insert_image("basn0g01.png", Some(MimeType("image/png".into())), data)
            .unwrap();

        assert_eq!(image.value(), 0);

        assert_eq!(builder.root.images.len(), 1);
        assert_eq!(builder.root.buffers.len(), 1);

        let (buffer_zero_idx, buffer_zero) = builder.unencoded_buffers.iter().next().unwrap();
        assert_eq!(*buffer_zero, data);

        let buffer_zero_type = builder.root.buffers.get(buffer_zero_idx.value()).unwrap();
        let image_typ = builder.root.images.first().unwrap();
        assert_eq!(buffer_zero_type.byte_length, data.len() as u32);
        assert_eq!(buffer_zero_type.name, Some("Autogenerated buffer 0".into()));
        assert_eq!(
            buffer_zero_idx.value(),
            image_typ.buffer_view.unwrap().value()
        );
        assert_eq!(image_typ.name, Some("basn0g01.png".into()));
        assert_eq!(
            image_typ.mime_type.clone().unwrap().0,
            "image/png".to_owned()
        );
    }

    #[test]
    fn test_texture() {
        let data = include_bytes!("test_files/basn0g01.png");

        let mut builder = glTFBuilder::new();
        let image = builder
            .insert_image("basn0g01.png", Some(MimeType("image/png".into())), data)
            .unwrap();

        builder.insert_texture("texture1", image).unwrap();

        assert_eq!(builder.root.textures.len(), 1);
        assert_eq!(builder.root.images.len(), 1);
        assert_eq!(builder.root.buffers.len(), 1);
        assert_eq!(builder.root.buffer_views.len(), 1);

        let texture_type = builder.root.textures.first().unwrap();
        assert_eq!(texture_type.name, Some("texture1".into()));
        assert_eq!(texture_type.source, image);
        assert_eq!(texture_type.sampler, None);
    }

    #[test]
    fn test_vec3() {
        let mut builder = glTFBuilder::new();
        builder
            .insert_vec3("positions", &[[0., 1., 0.], [-1., 0., 0.]])
            .unwrap();

        let (real_buffer, buffer_typ) = builder.get_buffer(Index::new(0));
        let accessor_type = builder.root.accessors.first().unwrap();

        assert_eq!(real_buffer.len(), size_of::<f32>() * 3 * 2);
        assert_eq!(buffer_typ.byte_length, real_buffer.len() as u32);
        assert_eq!(accessor_type.buffer_view, Some(Index::new(0)));
        assert_eq!(accessor_type.byte_offset, 0);
        assert_eq!(
            accessor_type.component_type.unwrap().0,
            gltf_json::accessor::ComponentType::F32
        );
        assert_eq!(accessor_type.type_.unwrap(), Type::Vec3);

        assert_eq!(
            accessor_type.min.as_ref().unwrap().to_string(),
            "[-1.0,0.0,0.0]"
        );
        assert_eq!(
            accessor_type.max.as_ref().unwrap().to_string(),
            "[0.0,1.0,0.0]"
        );
    }

    #[test]
    fn test_vec2() {
        let mut builder = glTFBuilder::new();
        builder
            .insert_vec2("positions", &[[0., 1.], [-1., 0.]])
            .unwrap();

        let (real_buffer, buffer_typ) = builder.get_buffer(Index::new(0));
        let accessor_type = builder.root.accessors.first().unwrap();

        assert_eq!(real_buffer.len(), size_of::<f32>() * 2 * 2);
        assert_eq!(buffer_typ.byte_length, real_buffer.len() as u32);
        assert_eq!(accessor_type.buffer_view, Some(Index::new(0)));
        assert_eq!(accessor_type.byte_offset, 0);
        assert_eq!(
            accessor_type.component_type.unwrap().0,
            gltf_json::accessor::ComponentType::F32
        );
        assert_eq!(accessor_type.type_.unwrap(), Type::Vec2);

        assert_eq!(
            accessor_type.min.as_ref().unwrap().to_string(),
            "[-1.0,0.0]"
        );
        assert_eq!(accessor_type.max.as_ref().unwrap().to_string(), "[0.0,1.0]");
    }

    #[test]
    fn test_mesh_builder() {
        let mut builder = glTFBuilder::new();

        let mesh = builder.insert_mesh("Test Mesh 1");
        let primitive = builder.insert_primitive(mesh, gltf_json::mesh::Mode::Triangles);

        builder
            .insert_positions(
                mesh,
                primitive,
                &[[0., 0., 0.], [0., 0., 1.], [0., 1., 0.5]],
            )
            .expect("Failed to insert positions");

        builder.check_validity().expect("Builder became invalid!");
    }
}
