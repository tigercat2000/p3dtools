use eyre::eyre;
use gltf_json::{
    accessor::{GenericComponentType, Type},
    buffer::{self},
    image::MimeType,
    validation::{Checked, Validate},
    Accessor, Buffer, Image, Index, Root, Texture, Value,
};
use serde_json::json;
use std::{collections::HashMap, mem::size_of};

pub type Result<T> = std::result::Result<T, eyre::Error>;

pub type Vector2 = [f32; 2];
pub type Vector3 = [f32; 3];
pub type Vector4 = [f32; 3];

/// 10 MB
const ARBITRARY_BUFFER_LENGTH_LIMIT: u32 = 2u32.pow(10 * 2);

/// This trait is used to add something to a list and returns the index it was put at.
trait PushReturnIndex {
    type Input;
    /// This adds something to a list and returns the index it was put at.
    fn push_indexed(&mut self, data: Self::Input) -> usize;
}

impl<T> PushReturnIndex for Vec<T> {
    type Input = T;

    fn push_indexed(&mut self, data: Self::Input) -> usize {
        self.push(data);
        self.len() - 1
    }
}

trait WriteGltf {
    fn write_gltf(&self, out: &mut Vec<u8>);
}

impl WriteGltf for [u8] {
    fn write_gltf(&self, out: &mut Vec<u8>) {
        out.extend(self);
    }
}

impl WriteGltf for u8 {
    fn write_gltf(&self, out: &mut Vec<u8>) {
        out.push(*self);
    }
}

impl WriteGltf for [u16] {
    fn write_gltf(&self, out: &mut Vec<u8>) {
        out.extend(self.iter().flat_map(|f| f.to_le_bytes()))
    }
}

impl WriteGltf for u16 {
    fn write_gltf(&self, out: &mut Vec<u8>) {
        out.extend(self.to_le_bytes())
    }
}

impl WriteGltf for [u32] {
    fn write_gltf(&self, out: &mut Vec<u8>) {
        out.extend(self.iter().flat_map(|f| f.to_le_bytes()))
    }
}

impl WriteGltf for u32 {
    fn write_gltf(&self, out: &mut Vec<u8>) {
        out.extend(self.to_le_bytes())
    }
}

impl WriteGltf for [f32] {
    fn write_gltf(&self, out: &mut Vec<u8>) {
        out.extend(self.iter().flat_map(|f| f.to_le_bytes()))
    }
}

impl WriteGltf for f32 {
    fn write_gltf(&self, out: &mut Vec<u8>) {
        out.extend(self.to_le_bytes())
    }
}

impl WriteGltf for Vec<Vector2> {
    fn write_gltf(&self, out: &mut Vec<u8>) {
        self.iter().for_each(|f| f.write_gltf(out))
    }
}

impl WriteGltf for Vec<Vector3> {
    fn write_gltf(&self, out: &mut Vec<u8>) {
        self.iter().for_each(|f| f.write_gltf(out))
    }
}

impl<T> WriteGltf for &T
where
    T: WriteGltf,
{
    fn write_gltf(&self, out: &mut Vec<u8>) {
        (*self).write_gltf(out)
    }
}

fn get_min_components_vec3(vec: &[Vector3]) -> Option<gltf_json::Value> {
    vec.iter()
        .copied()
        .reduce(|acc, chunk| {
            [
                acc[0].min(chunk[0]),
                acc[1].min(chunk[1]),
                acc[2].min(chunk[2]),
            ]
        })
        .map(|f| json!(f))
}

fn get_max_components_vec3(vec: &[Vector3]) -> Option<gltf_json::Value> {
    vec.iter()
        .copied()
        .reduce(|acc, chunk| {
            [
                acc[0].max(chunk[0]),
                acc[1].max(chunk[1]),
                acc[2].max(chunk[2]),
            ]
        })
        .map(|f| json!(f))
}

fn get_min_components_vec2(vec: &[Vector2]) -> Option<gltf_json::Value> {
    vec.iter()
        .copied()
        .reduce(|acc, chunk| [acc[0].min(chunk[0]), acc[1].min(chunk[1])])
        .map(|f| json!(f))
}

fn get_max_components_vec2(vec: &[Vector2]) -> Option<gltf_json::Value> {
    vec.iter()
        .copied()
        .reduce(|acc, chunk| [acc[0].max(chunk[0]), acc[1].max(chunk[1])])
        .map(|f| json!(f))
}

#[derive(Debug, Default)]
#[allow(non_camel_case_types)]
pub struct glTFBuilder {
    root: Root,
    unencoded_buffers: HashMap<Index<Buffer>, Vec<u8>>,
    autogenerated_index: usize,
}

/// Internal functions.
impl glTFBuilder {
    /// This will throw an [`Result::Err`] if the internal [`gltf_json`] validation of our [`Root`] fails.
    /// Used to ensure the state is always valid after every public function call.
    ///
    /// During the process of the call and during internal calls, the state is allowed to be invalid, as we hold a &mut self.
    /// This is unfortunately necessary because some operations require insertions into two different parts of the struct,
    /// which cannot be done in parallel.
    fn check_validity(&self) -> crate::Result<()> {
        // Skip validation in release mode.
        #[cfg(not(debug_assertions))]
        return Ok(());

        let mut errors = Vec::new();
        self.root
            .validate(&self.root, gltf_json::Path::new, &mut |path, error| {
                errors.push((path(), error))
            });

        // Make sure our mesh is valid!
        if !errors.is_empty() {
            return Err(eyre!("{:#?}", errors));
        }

        Ok(())
    }

    /// This helper returns an immutable reference to
    /// both the real unencoded data from [`glTFBuilder::unencoded_buffers`]
    /// as well as the [`Buffer`] entry, so that internal functions can view the
    /// data as if it were combined.
    fn get_buffer(&self, buffer: Index<Buffer>) -> (&Vec<u8>, &Buffer) {
        (
            self.unencoded_buffers.get(&buffer).unwrap(),
            self.root.buffers.get(buffer.value()).unwrap(),
        )
    }

    /// This helper returns a mutable reference to
    /// both the real unencoded data from [`glTFBuilder::unencoded_buffers`]
    /// as well as the [`Buffer`] entry, so that internal functions can mutate the
    /// data as if it were combined.
    fn get_buffer_mut(&mut self, buffer: Index<Buffer>) -> (&mut Vec<u8>, &mut Buffer) {
        (
            self.unencoded_buffers.get_mut(&buffer).unwrap(),
            self.root.buffers.get_mut(buffer.value()).unwrap(),
        )
    }

    /// This creates a new [`Buffer`] backed by a [`Vec<u8>`]
    /// in [`glTFBuilder::unencoded_buffers`].
    fn create_buffer(&mut self, name: Option<&str>) -> Index<Buffer> {
        let buffer_type = Buffer {
            byte_length: 0,
            name: name.map(|x| x.to_owned()),
            uri: None,
            extensions: None,
            extras: Default::default(),
        };

        let index = Index::new(self.root.buffers.push_indexed(buffer_type) as u32);

        self.unencoded_buffers.insert(index, Vec::new());

        index
    }

    /// This inserts additional data into an existing [`Buffer`] and
    /// creates a new [`buffer::View`] to that data, then returns
    /// an index to the newly created [`buffer::View`].
    ///
    /// This exists for skipping the overhead and... shakiness of [`WriteGltf`].
    fn insert_raw_data(
        &mut self,
        name: Option<&str>,
        buffer: Index<Buffer>,
        data: &[u8],
    ) -> Index<buffer::View> {
        let (real_buffer, buffer_type) = self.get_buffer_mut(buffer);

        // The index offset of the buffer view into this buffer will be whatever our current
        // length is. However, the glTF spec asks that we simply don't encode the offset if
        // it is 0, so we have to account for that.
        let potential_offset = real_buffer.len() as u32;
        let byte_offset = if potential_offset != 0 {
            Some(potential_offset)
        } else {
            None
        };

        // Write the data to the end of the real unencoded vec.
        real_buffer.extend(data);

        // Always synchronize the buffer_type length.
        buffer_type.byte_length = real_buffer.len() as u32;

        let buffer_view = buffer::View {
            buffer,
            byte_length: data.len() as u32,
            byte_offset,
            byte_stride: None,
            name: name.map(|x| x.to_owned()),
            target: None,
            extensions: None,
            extras: Default::default(),
        };

        Index::new(self.root.buffer_views.push_indexed(buffer_view) as u32)
    }

    /// This inserts additional data into an existing [`Buffer`] and
    /// creates a new [`buffer::View`] to that data, then returns
    /// an index to the newly created [`buffer::View`].
    fn insert_write_gltf<T: WriteGltf>(
        &mut self,
        name: Option<&str>,
        buffer: Index<Buffer>,
        data: T,
    ) -> Index<buffer::View> {
        let (real_buffer, buffer_type) = self.get_buffer_mut(buffer);

        // The index offset of the buffer view into this buffer will be whatever our current
        // length is. However, the glTF spec asks that we simply don't encode the offset if
        // it is 0, so we have to account for that.
        let potential_offset = real_buffer.len() as u32;
        let byte_offset = if potential_offset != 0 {
            Some(potential_offset)
        } else {
            None
        };

        data.write_gltf(real_buffer);

        let byte_length = real_buffer.len() as u32 - potential_offset;

        // Always synchronize the buffer_type length.
        buffer_type.byte_length = real_buffer.len() as u32;

        let buffer_view = buffer::View {
            buffer,
            byte_length,
            byte_offset,
            byte_stride: None,
            name: name.map(|x| x.to_owned()),
            target: None,
            extensions: None,
            extras: Default::default(),
        };

        Index::new(self.root.buffer_views.push_indexed(buffer_view) as u32)
    }

    /// Most accessor data types must be aligned. This has to be accounted for
    /// by adding padding to our [`Buffer`]s. This will automatically pad if needed.
    ///
    /// This won't cause any issues, as [`Buffer`]s are always accessed through
    /// [`BufferView`]s which we ensure are valid when they are created,
    /// and this function will never modify any data already referenced.
    ///
    /// Example: an f32 accessor will ask:
    /// ```no_compile
    /// self.pad_to_alignment(index, std::mem::size_of::<f32>());
    /// ```
    fn pad_to_alignment(&mut self, buffer: Index<Buffer>, alignment: usize) {
        let (real_buffer, buffer_type) = self.get_buffer_mut(buffer);

        // This may do nothing if it is already padded, that's okay.
        while real_buffer.len() % alignment != 0 {
            // Zero-pad.
            real_buffer.push(0);
        }

        // Update the byte length.
        buffer_type.byte_length = real_buffer.len() as u32;
    }

    /// Creates a new [`Accessor`] and immediately checks it's validity, otherwise fails.
    ///
    /// It is up to the caller to ensure the buffer_view is aligned correctly.
    #[allow(clippy::too_many_arguments)]
    fn create_accessor(
        &mut self,
        name: Option<&str>,
        buffer_view: Index<buffer::View>,
        byte_offset: u32,
        count: u32,
        component_type: Checked<GenericComponentType>,
        outer_type: Checked<Type>,
        min: Option<Value>,
        max: Option<Value>,
        normalized: bool,
    ) -> Result<Index<Accessor>> {
        let index = self.root.accessors.push_indexed(Accessor {
            buffer_view: Some(buffer_view),
            byte_offset,
            count,
            component_type,
            extensions: None,
            extras: Default::default(),
            type_: outer_type,
            min,
            max,
            name: name.map(|s| s.to_owned()),
            normalized,
            sparse: None,
        });

        self.check_validity()?;

        Ok(Index::new(index as u32))
    }

    fn create_accessor_vec3(
        &mut self,
        name: Option<&str>,
        buffer_view: Index<buffer::View>,
        data: &[Vector3],
    ) -> Result<Index<Accessor>> {
        self.create_accessor(
            name,
            buffer_view,
            0,
            data.len() as u32,
            Checked::Valid(GenericComponentType(
                gltf_json::accessor::ComponentType::F32,
            )),
            Checked::Valid(Type::Vec3),
            get_min_components_vec3(data),
            get_max_components_vec3(data),
            false,
        )
    }

    fn create_accessor_vec2(
        &mut self,
        name: Option<&str>,
        buffer_view: Index<buffer::View>,
        data: &[Vector2],
    ) -> Result<Index<Accessor>> {
        self.create_accessor(
            name,
            buffer_view,
            0,
            data.len() as u32,
            Checked::Valid(GenericComponentType(
                gltf_json::accessor::ComponentType::F32,
            )),
            Checked::Valid(Type::Vec2),
            get_min_components_vec2(data),
            get_max_components_vec2(data),
            false,
        )
    }

    fn auto_buffer(&mut self, data_size: usize) -> Index<Buffer> {
        if let Some(last) = self.root.buffers.last() {
            if last.byte_length + data_size as u32 > ARBITRARY_BUFFER_LENGTH_LIMIT {
                let buf = self.create_buffer(Some(&format!(
                    "Autogenerated buffer {}",
                    self.autogenerated_index
                )));
                self.autogenerated_index += 1;
                buf
            } else {
                Index::new(self.root.buffers.len() as u32 - 1)
            }
        } else {
            let buf = self.create_buffer(Some(&format!(
                "Autogenerated buffer {}",
                self.autogenerated_index
            )));
            self.autogenerated_index += 1;
            buf
        }
    }

    /// Steps to build:
    /// - Base64 encode [`glTFBuilder::unencoded_buffers`] and place them in their respective [`Buffer::uri`] fields.
    ///   - TODO: Eventually this should support the other two methods of storing buffers, glb and .bin files; do this here.
    /// - Return [`serde_json::to_string(root)`].
    fn build_internal(self) -> String {
        todo!()
    }
}

/// Public functions.
impl glTFBuilder {
    /// Constructs a new gltfBuilder with a valid, default internal representation.
    pub fn new() -> Self {
        Self::default()
    }

    /// Finalize the [`glTFBuilder`] and return the json encoded [`Root`].
    pub fn build(self) -> Result<String> {
        self.check_validity()?;
        Ok(self.build_internal())
    }

    /// Inserts an image.
    pub fn insert_image(
        &mut self,
        name: &str,
        mime_type: Option<MimeType>,
        data: &[u8],
    ) -> Result<Index<Image>> {
        let buffer = self.auto_buffer(data.len());
        let buffer_view = self.insert_raw_data(Some(name), buffer, data);

        let idx = self.root.images.push_indexed(Image {
            buffer_view: Some(buffer_view),
            mime_type,
            name: Some(name.into()),
            uri: None,
            extensions: None,
            extras: Default::default(),
        });

        self.check_validity()?;

        Ok(Index::new(idx as u32))
    }

    pub fn insert_texture(&mut self, name: &str, image: Index<Image>) -> Result<Index<Texture>> {
        let idx = self.root.textures.push_indexed(Texture {
            name: Some(name.to_owned()),
            // TODO: Change this if textures turn out badly
            sampler: None,
            source: image,
            extensions: None,
            extras: Default::default(),
        });

        self.check_validity()?;

        Ok(Index::new(idx as u32))
    }

    pub fn insert_vec3(&mut self, name: &str, data: &Vec<Vector3>) -> Result<Index<Accessor>> {
        let buffer = self.auto_buffer(data.len() * size_of::<f32>() * 3);
        self.pad_to_alignment(buffer, size_of::<f32>());
        let buffer_view = self.insert_write_gltf(Some(name), buffer, data);
        self.create_accessor_vec3(Some(name), buffer_view, data)
    }

    pub fn insert_vec2(&mut self, name: &str, data: &Vec<Vector2>) -> Result<Index<Accessor>> {
        let buffer = self.auto_buffer(data.len() * size_of::<f32>() * 2);
        self.pad_to_alignment(buffer, size_of::<f32>());
        let buffer_view = self.insert_write_gltf(Some(name), buffer, data);
        self.create_accessor_vec2(Some(name), buffer_view, data)
    }
}

#[cfg(test)]
mod tests {
    use crate::glTFBuilder;
    use gltf_json::{accessor::Type, image::MimeType, Buffer, Index};
    use std::mem::size_of;

    fn helper_setup_buffer(builder: &mut glTFBuilder) -> Index<Buffer> {
        let idx = builder.create_buffer(Some("Test Buffer"));
        assert_eq!(idx.value(), 0);
        idx
    }

    #[test]
    fn test_default_is_valid() {
        glTFBuilder::new().check_validity().unwrap()
    }

    #[test]
    fn test_buffer_is_created() {
        let mut builder = glTFBuilder::new();
        let index = helper_setup_buffer(&mut builder);

        assert_eq!(builder.root.buffers.len(), 1);

        let (_, new_buffer) = &builder.get_buffer(index);

        assert_eq!(new_buffer.byte_length, 0);
        assert_eq!(new_buffer.name, Some("Test Buffer".into()));
        assert_eq!(new_buffer.uri, None);

        builder.check_validity().unwrap()
    }

    #[test]
    fn test_buffer_view_is_created() {
        let mut builder = glTFBuilder::new();
        let buffer_idx = helper_setup_buffer(&mut builder);

        let buffer_view_idx = builder.insert_raw_data(Some("Test Data"), buffer_idx, &[1, 2, 3]);

        assert_eq!(buffer_view_idx.value(), 0);
        assert_eq!(builder.root.buffer_views.len(), 1);

        let new_buffer_view = &builder.root.buffer_views[0];

        assert_eq!(new_buffer_view.buffer.value(), 0);
        assert_eq!(new_buffer_view.byte_length, 3);
        assert_eq!(new_buffer_view.byte_offset, None);
        assert_eq!(new_buffer_view.name, Some("Test Data".into()));

        let existing_buffer = &builder.root.buffers[0];
        assert_eq!(existing_buffer.byte_length, 3);

        builder.check_validity().unwrap()
    }

    #[test]
    fn test_multiple_views() {
        let mut builder = glTFBuilder::new();
        let buffer_idx = helper_setup_buffer(&mut builder);
        let buffer_view_idx_1 = builder.insert_raw_data(Some("Test Data"), buffer_idx, &[1, 2, 3]);
        assert_eq!(buffer_view_idx_1.value(), 0);
        let buffer_view_idx_2 =
            builder.insert_raw_data(Some("Test Data 2"), buffer_idx, &[4, 5, 6]);
        assert_eq!(buffer_view_idx_2.value(), 1);

        let buffer_views = &builder.root.buffer_views;
        assert_eq!(buffer_views.len(), 2);
        assert_eq!(buffer_views[0].byte_length, 3);
        assert_eq!(buffer_views[1].byte_length, 3);
        assert_eq!(buffer_views[1].byte_offset, Some(3));

        assert_eq!(builder.root.buffers.len(), 1);
        let (real_buffer, buffer) = builder.get_buffer(buffer_idx);

        assert_eq!(buffer.byte_length, 6);
        assert_eq!(buffer.uri, None);
        assert_eq!(real_buffer.len() as u32, buffer.byte_length);
        assert_eq!(real_buffer.first(), Some(&1));
        assert_eq!(real_buffer.last(), Some(&6));

        builder.check_validity().unwrap()
    }

    #[test]
    fn test_padding() {
        let mut builder = glTFBuilder::new();
        let buffer_idx = helper_setup_buffer(&mut builder);
        let buffer_view = builder.insert_raw_data(None, buffer_idx, &[1, 2]);

        let (real_buffer, _) = builder.get_buffer(buffer_idx);
        assert_eq!(real_buffer.len(), 2);

        builder.pad_to_alignment(buffer_idx, std::mem::size_of::<f32>());

        let (real_buffer, _) = builder.get_buffer(buffer_idx);
        assert_eq!(real_buffer.len(), 4);

        assert_eq!(
            builder
                .root
                .buffer_views
                .get(buffer_view.value())
                .unwrap()
                .byte_length,
            2
        );

        // Should still be valid at this point.
        builder.check_validity().unwrap();

        let new_buffer_view = builder.insert_raw_data(None, buffer_idx, &[3, 4]);
        let (real_buffer, _) = builder.get_buffer(buffer_idx);
        assert_eq!(real_buffer.len(), 6);

        assert_eq!(
            builder
                .root
                .buffer_views
                .get(new_buffer_view.value())
                .unwrap()
                .byte_offset,
            Some(4)
        );

        // Should still be valid at this point.
        builder.check_validity().unwrap();
    }

    #[test]
    fn test_image() {
        let data = include_bytes!("test_files/basn0g01.png");

        let mut builder = glTFBuilder::new();
        let image = builder
            .insert_image("basn0g01.png", Some(MimeType("image/png".into())), data)
            .unwrap();

        assert_eq!(image.value(), 0);

        assert_eq!(builder.root.images.len(), 1);
        assert_eq!(builder.root.buffers.len(), 1);

        let (buffer_zero_idx, buffer_zero) = builder.unencoded_buffers.iter().next().unwrap();
        assert_eq!(*buffer_zero, data);

        let buffer_zero_type = builder.root.buffers.get(buffer_zero_idx.value()).unwrap();
        let image_typ = builder.root.images.first().unwrap();
        assert_eq!(buffer_zero_type.byte_length, data.len() as u32);
        assert_eq!(buffer_zero_type.name, Some("Autogenerated buffer 0".into()));
        assert_eq!(
            buffer_zero_idx.value(),
            image_typ.buffer_view.unwrap().value()
        );
        assert_eq!(image_typ.name, Some("basn0g01.png".into()));
        assert_eq!(
            image_typ.mime_type.clone().unwrap().0,
            "image/png".to_owned()
        );
    }

    #[test]
    fn test_texture() {
        let data = include_bytes!("test_files/basn0g01.png");

        let mut builder = glTFBuilder::new();
        let image = builder
            .insert_image("basn0g01.png", Some(MimeType("image/png".into())), data)
            .unwrap();

        builder.insert_texture("texture1", image).unwrap();

        assert_eq!(builder.root.textures.len(), 1);
        assert_eq!(builder.root.images.len(), 1);
        assert_eq!(builder.root.buffers.len(), 1);
        assert_eq!(builder.root.buffer_views.len(), 1);

        let texture_type = builder.root.textures.first().unwrap();
        assert_eq!(texture_type.name, Some("texture1".into()));
        assert_eq!(texture_type.source, image);
        assert_eq!(texture_type.sampler, None);
    }

    #[test]
    fn test_vec3() {
        let mut builder = glTFBuilder::new();
        builder
            .insert_vec3("positions", &vec![[0., 1., 0.], [-1., 0., 0.]])
            .unwrap();

        let (real_buffer, buffer_typ) = builder.get_buffer(Index::new(0));
        let accessor_type = builder.root.accessors.first().unwrap();

        assert_eq!(real_buffer.len(), size_of::<f32>() * 3 * 2);
        assert_eq!(buffer_typ.byte_length, real_buffer.len() as u32);
        assert_eq!(accessor_type.buffer_view, Some(Index::new(0)));
        assert_eq!(accessor_type.byte_offset, 0);
        assert_eq!(
            accessor_type.component_type.unwrap().0,
            gltf_json::accessor::ComponentType::F32
        );
        assert_eq!(accessor_type.type_.unwrap(), Type::Vec3);

        assert_eq!(
            accessor_type.min.as_ref().unwrap().to_string(),
            "[-1.0,0.0,0.0]"
        );
        assert_eq!(
            accessor_type.max.as_ref().unwrap().to_string(),
            "[0.0,1.0,0.0]"
        );
    }

    #[test]
    fn test_vec2() {
        let mut builder = glTFBuilder::new();
        builder
            .insert_vec2("positions", &vec![[0., 1.], [-1., 0.]])
            .unwrap();

        let (real_buffer, buffer_typ) = builder.get_buffer(Index::new(0));
        let accessor_type = builder.root.accessors.first().unwrap();

        assert_eq!(real_buffer.len(), size_of::<f32>() * 2 * 2);
        assert_eq!(buffer_typ.byte_length, real_buffer.len() as u32);
        assert_eq!(accessor_type.buffer_view, Some(Index::new(0)));
        assert_eq!(accessor_type.byte_offset, 0);
        assert_eq!(
            accessor_type.component_type.unwrap().0,
            gltf_json::accessor::ComponentType::F32
        );
        assert_eq!(accessor_type.type_.unwrap(), Type::Vec2);

        assert_eq!(
            accessor_type.min.as_ref().unwrap().to_string(),
            "[-1.0,0.0]"
        );
        assert_eq!(accessor_type.max.as_ref().unwrap().to_string(), "[0.0,1.0]");
    }
}
